### java中位运算^,&,<<,>>,<<<,>>>总结

**1.^(亦或运算) ，**针对二进制，相同的为0，不同的为1

例子:2^3

```java
2 =======>0010
3 =======>0011
结果是 0001 ，十进制即为 1
```



**2.&（与运算）** 针对二进制，只要有一个为0，就为0。除了与运算，还有一个作用就是 **长路与**  ，指在&的两边的表达式都要被执行，与&&(短路与)的区别就是短路与是只要有一边是false,那么另外一边的表达式就不会被执行。

例子：2&3

```java
2 =======>0010
3 =======>0011
结果是 0010 ，十进制即为 2
```



**3.<<(向左位移)** 针对二进制，转换成二进制后向左移动3位，后面用0补齐

例子：2<<3   (将2向左移动3位)

```java
2 =======>0000 0010
向左移动3位后：
  =======>0001 0000
 十进制即为：16
```



**4.>>(向右位移)** 针对二进制，转换成二进制后向右移动3位

例子：2>>3 (将2向右移动3位)

```java
2 =======>0000 0010
向右移动3位后：
  =======>0000 0000
即为： 0
```



**5.>>>(无符号右移)**  无符号右移，忽略符号位，空位都以0补齐，**在计算机中负数采用二进制的补码表示，10进制转为二进制得到的是源码，将源码按位取反得到的是反码，反码加1得到补码**，在转换过程中，最高位就是符号位，0表示正，1表示负。>>>与>>唯一的不同是它无论原来的最左边是什么数，统统都用0填充。**比如，byte是8位的，-1表示为byte型是11111111(补码表示法）**



正数做>>>运算的时候和>>是一样的。区别在于负数运算。

例1：16>>>2

注：16是int型，是4字节32位，又因为是正数，所以前面的24位都是0，省略没写而已。

```java
16 =======>0001 0000   
向右无符号右移2位后：
   =======>0000 0100
十进制即为：4
```

例2：-16>>>2

```java
16 =======>0000 0000 0000 0000 0000 0000 0001 0000
按位取反后：
   =======>1111 1111 1111 1111 1111 1111 1110 1111
再加1：（此时为-16）
   =======>1111 1111 1111 1111 1111 1111 1111 0000
最后右移2位：
   =======>0011 1111 1111 1111 1111 1111 1111 1100
十进制即为：1073741820
```



### 方法的重载和重写

**重载**：定义：Java的方法重载，就是在类中可以创建多个方法，它们可以有相同的名字，但**必须具有不同的参数，即或者是参数的个数不同，或者是参数的类型不同**。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法。

**注**：方法重载是不考虑方法返回类型和参数名称的。比如以下：

```java
1.  public void aMethod(int a,int b){}
2.  public String  aMethod(String b,String c){}
3.  public int  aMethod(int b,int c){}
```

上面的三个方法中，1和2是方法重载，2和3是方法重载,而1和3不是方法重载 



**重写：**子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。

​	若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。 如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。

**特性**：

关于方法重写的一些特性：

1.发生方法重写的两个方法返回值、方法名、参数列表必须完全一致(子类重写父类的方法)

2.子类抛出的异常下不能超过父类相应方法抛出的异常(子类异常不能大于父类异常)

3.子类方法的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)

根据2，3条可以确定第一条，子类重写父类方法的返回值类型不能大于父类方法的返回值类型，即是说子类方法的返回值必须和父类方法的返回值相同或是其子类。

**注**：方法重写与方法重载不同，方法的重载是方法的参数个数或类型不同，方法名相同。方法重写是要注意权限的问题，子类中的权限不能小于父类的权限，当父类的权限为private时，子类无法继承。也就无法产生所谓的重写。（修饰符高低：private < 默认修饰符 <protected< public）



### 抽象类

含有抽象方法的类称为抽象类，不能生成对象，即不能被new ,只能被继承；

抽象类当中可以存在非抽象的方法（普通方法）、成员变量、构造方法；



### 接口

​	Java接口本身没有任何实现，因为Java接口不涉及表象，而只描述public行为，所以Java接口比Java抽象类更抽象化。但是接口不是类，不能使用new 运算符实例化一个接口。Java接口的方法只能是抽象的和公开的，**Java接口不能有构造器**，*Java接口可以有public、static和final属性。即接口中的属性可以定义为 public static final int value=5;*

**java中类是单继承，多实现的，接口可以多继承。**



### 集合（容器）

#### 1.Collection:

* List(有序，可重复，遍历方式：for、iterator)
  * ArrayList 底层用数组实现。线程不安全，查询效率高。
  * LinkList 底层用双向链表实现。线程不安全，插入、删除的效率高。
* Set (无序，不可重复，遍历方式：foreach、iterator)
  * HashSet 内部用HashMap实现

#### 2.Map(键值对形式)

* HashMap 线程不安全，效率高
* HashTable 线程安全，效率低



